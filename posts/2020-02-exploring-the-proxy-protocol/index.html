<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Exploring the PROXY Protocol - Benjamin Boudreau</title><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=referrer content="no-referrer"><meta name=description content><meta property="og:site_name" content="Benjamin Boudreau"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:url" content="https://seriousben.com/posts/2020-02-exploring-the-proxy-protocol/"><meta property="og:title" content="Exploring the PROXY Protocol"><meta property="og:image" content="https://seriousben.com/"><meta property="og:description" content><meta property="twitter:site" content="@seriousben"><meta property="twitter:title" content="Exploring the PROXY Protocol"><meta property="twitter:image" content="https://seriousben.com/"><meta property="twitter:card" content="summary"><meta property="twitter:description" content><link rel=canonical href=https://seriousben.com/posts/2020-02-exploring-the-proxy-protocol/><link rel=stylesheet href=https://seriousben.com/style.d44234584139078e87c89dd53eda56c2d1f231c980bdd5bfb6b2e6b4f6bc6f43.css integrity="sha256-1EI0WEE5B46HyJ3VPtpWwtHyMcmAvdW/trLmtPa8b0M=" crossorigin=anonymous><link rel=stylesheet href=https://seriousben.com/css/highlight.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#000><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title="Benjamin Boudreau"></head><body><div class=container><header><div class=title-wrapper><a href=https://seriousben.com/>Serious Ben</a></div><div class=menu><ol><li><a class="text-uppercase nav-link" href=/posts/>Posts</a></li><li><a class="text-uppercase nav-link" href=/links/>Curated Links</a></li></ol></div></header><div class=content><h1>Exploring the PROXY Protocol</h1><div class=meta><span class=date title='Sun Feb 23 2020 20:00:00 -0500'>February 23, 2020
</span>&bull;
<span class="reading-time middot">18 minutes</span></div><div class=toc><strong>Contents</strong><nav id=TableOfContents><ul><li><a href=#why-do-we-need-the-proxy-protocol>Why do we need the PROXY protocol?</a></li><li><a href=#version-1-specification>Version 1 Specification</a></li><li><a href=#version-2-specification>Version 2 Specification</a></li><li><a href=#security-considerations>Security Considerations</a></li><li><a href=#deep-dive>Deep Dive</a><ul><li><a href=#proxy-protocol-version-1>PROXY protocol version 1</a></li><li><a href=#proxy-protocol-version-1-or-2-to-application>PROXY protocol version 1 or 2 to Application</a></li><li><a href=#proxy-protocol-version-2>PROXY protocol version 2</a></li><li><a href=#two-hops-tcp-proxies-resulting-in-two-proxy-protocol-header>Two hops TCP proxies resulting in two PROXY protocol header</a></li></ul></li><li><a href=#implementing-a-proxy-protocol-parser>Implementing a PROXY protocol parser</a><ul><li><a href=#parsing-version-1>Parsing Version 1</a></li><li><a href=#parsing-version-2>Parsing Version 2</a></li></ul></li><li><a href=#real-life-usage>Real-life Usage</a><ul><li><a href=#azure>Azure</a></li><li><a href=#google-cloud-platform>Google Cloud Platform</a></li><li><a href=#amazon-web-services>Amazon Web Services</a></li><li><a href=#cloudflare>Cloudflare</a></li><li><a href=#digitalocean>DigitalOcean</a></li><li><a href=#linode>Linode</a></li><li><a href=#rackspace>Rackspace</a></li></ul></li><li><a href=#alternatives>Alternatives</a></li><li><a href=#conclusion>Conclusion</a></li></ul></nav></div><div class=article-content><p>Some time ago, I needed to load balance websocket connections over AWS Elastic Load Balancers (ELB) or Classic Load Balancers as they are now called. But ELBs did not (and still don&rsquo;t) support proxying websocket traffic over their HTTP(S) listener. To support websocket traffic, a TCP listener is required. This means that the proxy server (ELB) looses knowledge of the HTTP protocol since it goes from being a layer 7 (application) proxy to being a layer 4 (transport) proxy. Without knowledge of HTTP, the proxy can&rsquo;t add the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For target=_blank rel=noopener><code>X-Forwarded-For</code> HTTP header</a>
to let upstream servers know what the original client IP address is.</p><p>This problem is exactly what the PROXY protocol has been created to solve. It allows &ldquo;Application Protocol&rdquo; agnostic proxies (or &ldquo;dumb proxies&rdquo; like its <a href=http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt target=_blank rel=noopener>specification</a>
calls them) to inject data about the calling client in the request being proxied without knowing about the proxied protocol by staying efficient.</p><p>Let&rsquo;s look at how this PROXY protocol works.</p><h2 id=why-do-we-need-the-proxy-protocol>Why do we need the PROXY protocol?</h2><p>First, let&rsquo;s go through the <a href=http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt target=_blank rel=noopener>PROXY protocol specification</a>
. It was created by HAProxy in 2010 and since then as gone through 6 different updates. The last update to the specification was introduced in 2017. It has evolved since its creation into two versions which I explain in more details later.</p><p>The abstract of the protocol does a good job of explaining the why of it:</p><blockquote><p>The PROXY protocol provides a convenient way to safely transport connection
information such as a client&rsquo;s address across multiple layers of NAT or TCP
proxies. It is designed to require little changes to existing components and
to limit the performance impact caused by the processing of the transported
information.</p></blockquote><p>To explain it in my own words. The goal of the PROXY protocol is to allow TCP &ldquo;dumb proxies&rdquo;, proxies operating at the transport layer (layer 4 of the <a href=https://en.wikipedia.org/wiki/OSI_model target=_blank rel=noopener>OSI model</a>
), to inject data about the original source and destination addresses to their upstream servers without knowledge of the underlying protocol. The PROXY protocol is designed to support any application layer protocol like FTP, SMTP, IMAP, MySQL Protocol, and other protocols built on top of TCP or UDP. As can be seen with this extensive list of protocols, it enables a given proxy implementing adding the PROXY protocol header to a request to expose data on the original client without knowing anything about the protocol being proxied and therefore being more lightweight and not having to evolve to follow additions to higher level protocols like having to know about <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For target=_blank rel=noopener><code>X-Forwarded-For</code></a>
and its replacement <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded target=_blank rel=noopener>the <code>Forwarded</code> header</a>
for HTTP.</p><figure class=large-figure><img src=/posts/2020-02-exploring-the-proxy-protocol/before-after.svg alt="With vs Without PROXY protocol"></figure><h2 id=version-1-specification>Version 1 Specification</h2><p>The version 1 of the protocol is text based. It is human readable and therefore faciliates adoption and implementations.</p><p>Here is a text representation of an HTTP request containing the PROXY protocol version 1 header:</p><pre tabindex=0><code>PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\r\n
GET / HTTP/1.1\r\n
Host: 192.168.0.11\r\n
\r\n
</code></pre><figure class=large-figure><img src=/posts/2020-02-exploring-the-proxy-protocol/version1.svg alt="Version 1"></figure><p>All version 1 fields are separated by exactly one space <code>" "</code> (<code>\x20</code>):</p><dl><dt>Signature</dt><dd>Constant 5 bytes identifying the first line of a request as being a version 1 PROXY protocol line.</dd><dd><strong>Position:</strong> 0</dd><dd><strong>Value:</strong> <code>PROXY</code> -><code>\x50 \x52 \x4F \x58 \x59</code></dd><dt>INET Protocol</dt><dd>Proxied protocol and family. Only TCP and TCP6 allowed.</dd><dt>Source Address</dt><dd>IPv4 for TCP or IPv6 for TCP6.</dd><dt>Destination Address</dt><dd>IPv4 for TCP or IPv6 for TCP6.</dd><dt>Source Port</dt><dd>Number between 0..65535</dd><dt>Destination Port</dt><dd>Number between 0..65535</dd></dl><h2 id=version-2-specification>Version 2 Specification</h2><p>The version 2 of the protocol is binary based which means that bits and bytes positioning are defined as part of the protocol.</p><p>The <a href=https://developers.cloudflare.com/spectrum/getting-started/proxy-protocol/ target=_blank rel=noopener>Cloudflare PROXY protocol documentation</a>
does a very good job of explaining the protocol. Specifically, it provides a protocol header diagram giving a very good high level view of the binary representation of the PROXY protocol version 2:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>     0                   1                   2                   3
</span></span><span style=display:flex><span>Bits 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</span></span><span style=display:flex><span>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span style=display:flex><span>    |                                                               |
</span></span><span style=display:flex><span>    +                                                               +
</span></span><span style=display:flex><span>    |                  Proxy Protocol v2 Signature                  |
</span></span><span style=display:flex><span>    +                                                               +
</span></span><span style=display:flex><span>    |                                                               |
</span></span><span style=display:flex><span>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span style=display:flex><span>    |Version|Command|   AF  | Proto.|         Address Length        |
</span></span><span style=display:flex><span>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span style=display:flex><span>    |                      IPv4 Source Address                      |
</span></span><span style=display:flex><span>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span style=display:flex><span>    |                    IPv4 Destination Address                   |
</span></span><span style=display:flex><span>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span style=display:flex><span>    |          Source Port          |        Destination Port       |
</span></span><span style=display:flex><span>    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    |&lt;---------------------      32 bits     ----------------------&gt;|
</span></span><span style=display:flex><span>    |      Byte     |      Byte     |      Byte     |     Byte      |
</span></span></code></pre></div><p>(This diagram and explanation only refers to TCP + IPv4. Other representations exist for UDP, IPv6 and UNIX sockets.)</p><p>Reading this diagram:</p><ul><li>Every tick represents a one bit position</li><li>Every line contains 32 bits or 4 bytes (8 * 4)</li></ul><p>Here is an hexadecimal representation of an HTTP request containing the PROXY protocol version 2 header:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>0d 0a 0d 0a 00 0d 0a 51  55 49 54 0a 21 11 00 0c  |.......QUIT.!...|
</span></span><span style=display:flex><span>ac 13 00 01 ac 13 00 03  a6 52 00 50 47 45 54 20  |.........R.PGET |
</span></span><span style=display:flex><span>2f 20 48 54 54 50 2f 31  2e 31 0d 0a 48 6f 73 74  |/ HTTP/1.1..Host|
</span></span><span style=display:flex><span>3a 20 6c 6f 63 61 6c 68  6f 73 74 3a 38 30 38 30  |: localhost:8080|
</span></span><span style=display:flex><span>0d 0a 0d 0a                                       |....|
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;---------------     Bytes     ----------------&gt;  &lt;----  ASCII ----&gt;
</span></span></code></pre></div><p>The fields of version one are defined with a position and bit representation:</p><dl><dt>Signature</dt><dd>Constant 12 bytes allow an proxy to identify that the request starts with a PROXY protocol header.</dd><dd><strong>Length:</strong> 3 * 32 bits = 12 bytes</dd><dd><strong>Position:</strong> bytes 0 to 11</dd><dd><strong>Value:</strong> <code>\x0D \x0A \x0D \x0A \x00 \x0D \x0A \x51 \x55 \x49 \x54 \x0A</code></dd><dt>Version</dt><dd>Constant 4 bits that must always be equal to <code>\x2</code> version 2. Only uses the 4 highest bits of the 13th byte. The other 4 bits are used by the command field.</dd><dd><strong>Length:</strong> 4 bits.</dd><dd><strong>Position:</strong> Highest 4 bits of the 13th byte.</dd><dd><strong>Value:</strong> <code>\x2</code> (binary: <code>0010</code>)</dd><dt>Command</dt><dd>Indicates whether the request was proxied or not. It is useful to know if the addresses should be ignored or not.</dd><dd><strong>Length</strong>: 4 bits.</dd><dd><strong>Position:</strong> Lowest 4 bits of the 13th byte.</dd><dd><strong>Value</strong>:<ul><li><code>\x0</code> (binary: <code>0000</code>): <code>LOCAL</code>: request is not from a proxy.</li><li><code>\x1</code> (binary: <code>0001</code>): <code>PROXY</code>: request is from a proxy.</li></ul></dd><dt>Address Family</dt><dd>Original Address Family of the socket used to connect to the proxy.</dd><dd><strong>Length</strong>: 4 bits.</dd><dd><strong>Position:</strong> Highest 4 bits of the 14th byte.</dd><dd><strong>Value</strong>:<ul><li><code>\x0</code> (binary: <code>0000</code>): <code>AF_UNSET</code>: Used for the <code>LOCAL</code> command.</li><li><code>\x1</code> (binary: <code>0001</code>): <code>AF_INET</code>: IPv4</li><li><code>\x2</code> (binary: <code>0010</code>): <code>AF_INET6</code>: IPv6</li><li><code>\x3</code> (binary: <code>0011</code>): <code>AF_UNIX</code>: UNIX</li></ul></dd><dt>Transport Protocol</dt><dd>The protocol used to connect to the proxy. With the Address Family, we can infer the addresses types and length.<ul><li><code>AF_INET</code> + <code>STREAM</code>: TCP over IPv4</li><li><code>AF_INET</code> + <code>DGRAM</code>: UDP over IPv4</li><li><code>AF_INET6</code> + <code>STREAM</code>: UDP over IPv4</li><li><code>AF_INET6</code> + <code>DGRAM</code>: UDP over IPv6</li><li><code>AF_UNIX</code> + <code>STREAM</code>: UNIX stream</li><li><code>AF_UNIX</code> + <code>DGRAM</code>: UNIX datagram</li></ul></dd><dd><strong>Length</strong>: 4 bits.</dd><dd><strong>Position:</strong> Lowest 4 bits of the 14th byte.</dd><dd><strong>Value</strong>:<ul><li><code>\x0</code> (binary: <code>0000</code>): <code>AF_UNSET</code>: Used for the <code>LOCAL</code> command.</li><li><code>\x1</code> (binary: <code>0001</code>): <code>STREAM</code>: TCP</li><li><code>\x2</code> (binary: <code>0010</code>): <code>DGRAM</code>: Datagram (UDP or SOCK_DGRAM)</li></ul></dd><dt>Address Length</dt><dd>The length of the address fields (source, destination) addresses and port. In <a href=https://en.wikipedia.org/wiki/Endianness target=_blank rel=noopener>Network Order (Big Endian)</a>
, which means the most significant byte is at the lowest address. The length of the address + the number of bytes before the address is the total length of the header.</dd><dd><strong>Length</strong>: 2 * 8 bits = 2 bytes.</dd><dd><strong>Position:</strong> 15th and 16th bytes.</dd><dt>Source Address</dt><dd>The source address of the request. Each byte represent an integer from 0 to 255.</dd><dd><strong>Length</strong>: 4 bytes (IPv4)</dd><dd><strong>Position</strong>: 17th to 20th bytes (IPv4)</dd><dt>Destination Address</dt><dd>The destination address of the request. Each byte represent an integer from 0 to 255.</dd><dd><strong>Length</strong>: 4 bytes (IPv4)</dd><dd><strong>Position</strong>: 21th to 24th bytes (IPv4)</dd><dt>Source Port</dt><dd>The source port of the request. The bytes are in <a href=https://en.wikipedia.org/wiki/Endianness target=_blank rel=noopener>Network Order (Big Endian)</a>
. Which means the most significant byte is at the lowest address.</dd><dd><strong>Length</strong>: 2 bytes (IPv4)</dd><dd><strong>Position</strong>: 25th and 26th bytes (IPv4)</dd><dt>Destination Port</dt><dd>The destination port of the request. The bytes are in <a href=https://en.wikipedia.org/wiki/Endianness target=_blank rel=noopener>Network Order (Big Endian)</a>
. Which means the most significant byte is at the lowest address.</dd><dd><strong>Length</strong>: 2 bytes (IPv4)</dd><dd><strong>Position</strong>: 27th and 28th bytes (IPv4)</dd></dl><h2 id=security-considerations>Security Considerations</h2><p>The PROXY protocol specification raises important security considerations. Here are the main concerns. Please consult the specification for the full list.</p><ul><li>Receivers MUST only accept the PROXY protocol if configured to do so.</li><li>Receivers MUST only accept the PROXY protocol header from a trusted downstream proxies.</li><li>Receivers MUST not try to guess whether the PROXY protocol header is present or not.</li></ul><p>These considerations are there to make sure that a downstream client cannot inject a PROXY protocol header without the receiver trusting the downstream client. Not enforcing this would allow any client to override the client IP and obfuscate itself.</p><h2 id=deep-dive>Deep Dive</h2><p>Now that we covered the specification, let&rsquo;s try to experiment with the concept. It would be useful to test current implementations of the protocol and have a look at the version 1 and 2 header that gets written on a TCP stream.</p><p>To setup a testing environment, I used <code>docker-compose</code> to quickly have a networking environment and various components. To test the protocol we need these components:</p><ol><li><strong>nginx-edge</strong>: a TCP proxy configured to add the PROXY protocol version 1 header to proxied requests.</li><li><strong>haproxy-edge</strong>: a TCP proxy configured to add the PROXY protocol version 2 header to proxied requests.</li><li><strong>nginx-proxy</strong>: an HTTP proxy configured to read incoming PROXY protocol version 1 and 2 headers and to add the X-Forwarded-For header to proxied requests.</li><li><strong>netcat</strong>: a TCP server printing the TCP request. Also used to print in hexadecimal format to inspect version 2 requests.</li></ol><p>Here are all the components together:<figure><img src=/posts/2020-02-exploring-the-proxy-protocol/experiment-overview.svg alt="Experiment Overview"></figure></p><h3 id=proxy-protocol-version-1>PROXY protocol version 1</h3><figure><img src=/posts/2020-02-exploring-the-proxy-protocol/experiment-scenario1.svg alt="Scenario 1"></figure><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>&gt; curl -v http://localhost/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>netcat_1  | PROXY TCP4 172.19.0.1 172.19.0.3 42272 80
</span></span><span style=display:flex><span>netcat_1  | GET / HTTP/1.1
</span></span><span style=display:flex><span>netcat_1  | Host: localhost:8080
</span></span><span style=display:flex><span>netcat_1  | User-Agent: curl/7.68.0
</span></span><span style=display:flex><span>netcat_1  | Accept: */*
</span></span></code></pre></div><h3 id=proxy-protocol-version-1-or-2-to-application>PROXY protocol version 1 or 2 to Application</h3><figure><img src=/posts/2020-02-exploring-the-proxy-protocol/experiment-scenario2.svg alt="Scenario 2"></figure><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>&gt; curl -v http://localhost/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>netcat_1  | GET / HTTP/1.0
</span></span><span style=display:flex><span>netcat_1  | Host: localhost
</span></span><span style=display:flex><span>netcat_1  | X-Real-IP: 172.19.0.1
</span></span><span style=display:flex><span>netcat_1  | X-Forwarded-For: 172.19.0.1
</span></span><span style=display:flex><span>netcat_1  | Connection: close
</span></span><span style=display:flex><span>netcat_1  | User-Agent: curl/7.68.0
</span></span><span style=display:flex><span>netcat_1  | Accept: */*
</span></span></code></pre></div><h3 id=proxy-protocol-version-2>PROXY protocol version 2</h3><figure><img src=/posts/2020-02-exploring-the-proxy-protocol/experiment-scenario3.svg alt="Scenario 3"></figure><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>&gt; curl -v http://localhost/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>netcat_1        | 00000000  0d 0a 0d 0a 00 0d 0a 51  55 49 54 0a 21 11 00 0c  |.......QUIT.!...|
</span></span><span style=display:flex><span>netcat_1        | 00000010  ac 13 00 01 ac 13 00 03  a6 52 00 50 47 45 54 20  |.........R.PGET |
</span></span><span style=display:flex><span>netcat_1        | 00000020  2f 20 48 54 54 50 2f 31  2e 31 0d 0a 48 6f 73 74  |/ HTTP/1.1..Host|
</span></span><span style=display:flex><span>netcat_1        | 00000030  3a 20 6c 6f 63 61 6c 68  6f 73 74 3a 38 30 38 30  |: localhost:8080|
</span></span><span style=display:flex><span>netcat_1        | 00000040  0d 0a 55 73 65 72 2d 41  67 65 6e 74 3a 20 63 75  |..User-Agent: cu|
</span></span><span style=display:flex><span>netcat_1        | 00000050  72 6c 2f 37 2e 36 38 2e  30 0d 0a 41 63 63 65 70  |rl/7.68.0..Accep|
</span></span><span style=display:flex><span>netcat_1        | 00000060  74 3a 20 2a 2f 2a 0d 0a  0d 0a                    |t: */*....|
</span></span><span style=display:flex><span>netcat_1        | 0000006a
</span></span></code></pre></div><h3 id=two-hops-tcp-proxies-resulting-in-two-proxy-protocol-header>Two hops TCP proxies resulting in two PROXY protocol header</h3><figure><img src=/posts/2020-02-exploring-the-proxy-protocol/experiment-scenario4.svg alt="Scenario 4"></figure><p>Notice the two PROXY protocol headers prepended to the request. First a version 1 and then a version 2.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-plaintext data-lang=plaintext><span style=display:flex><span>netcat_1          | 00000000  0d 0a 0d 0a 00 0d 0a 51  55 49 54 0a 21 11 00 0c  |.......QUIT.!...|
</span></span><span style=display:flex><span>netcat_1          | 00000010  ac 14 00 06 ac 14 00 03  cb 50 00 50 50 52 4f 58  |.........P.PPROX|
</span></span><span style=display:flex><span>netcat_1          | 00000020  59 20 54 43 50 34 20 31  37 32 2e 32 30 2e 30 2e  |Y TCP4 172.20.0.|
</span></span><span style=display:flex><span>netcat_1          | 00000030  31 20 31 37 32 2e 32 30  2e 30 2e 36 20 34 30 36  |1 172.20.0.6 406|
</span></span><span style=display:flex><span>netcat_1          | 00000040  33 34 20 38 30 0d 0a 47  45 54 20 2f 20 48 54 54  |34 80..GET / HTT|
</span></span><span style=display:flex><span>netcat_1          | 00000050  50 2f 31 2e 31 0d 0a 48  6f 73 74 3a 20 31 32 37  |P/1.1..Host: 127|
</span></span><span style=display:flex><span>netcat_1          | 00000060  2e 30 2e 30 2e 31 3a 38  30 38 32 0d 0a 55 73 65  |.0.0.1:8082..Use|
</span></span><span style=display:flex><span>netcat_1          | 00000070  72 2d 41 67 65 6e 74 3a  20 63 75 72 6c 2f 37 2e  |r-Agent: curl/7.|
</span></span><span style=display:flex><span>netcat_1          | 00000080  36 38 2e 30 0d 0a 41 63  63 65 70 74 3a 20 2a 2f  |68.0..Accept: */|
</span></span><span style=display:flex><span>netcat_1          | 00000090  2a 0d 0a 0d 0a                                    |*....|
</span></span><span style=display:flex><span>netcat_1          | 00000095
</span></span></code></pre></div><h2 id=implementing-a-proxy-protocol-parser>Implementing a PROXY protocol parser</h2><p>After reading the specification and experimenting a little with some proxies, I started to have a pretty good mental
model of the PROXY protocol and how it integrated with TCP.</p><p>One thing I had more trouble with is how to parse the header and use the data it contained. Here is how I did it for each protocol version.</p><h3 id=parsing-version-1>Parsing Version 1</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>version1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bufio&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ProxyInfo represents the PROXY protocol information.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ProxyInfo</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Version</span>    <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AddrFamily</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SrcAddr</span>    <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SrcPort</span>    <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DstAddr</span>    <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DstPort</span>    <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// MaybeParseVersion1 returns information about the proxy header if contained in</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// the buffered reader of an incoming request.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// No bytes are read from the buffered reader if there is no PROXY protocol header</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// prepended to the request.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If a PROXY protocol header is found, only the bytes of the PROXY protocol</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// are consumed from the reader to allow the rest of the bytes to be used for</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// a layer 7 protocol for example HTTP.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MaybeParseVersion1</span>(<span style=color:#a6e22e>bufReader</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>Reader</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>ProxyInfo</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Only peek at 5 bytes to check if it starts with PROXY</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sigBytes</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufReader</span>.<span style=color:#a6e22e>Peek</span>(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;peek error: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Is the request data starting with `PROXY`?</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>isV1</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>sigBytes</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>sigBytes</span>[:<span style=color:#ae81ff>5</span>], []byte(<span style=color:#e6db74>&#34;PROXY&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>isV1</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// read until CRLF \r\n</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>line</span>, <span style=color:#a6e22e>isPrefix</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufReader</span>.<span style=color:#a6e22e>ReadLine</span>()
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;version 1 readLine error: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>isPrefix</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;version 1 line too long&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// split fields by space</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sections</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>line</span>, []byte(<span style=color:#e6db74>&#34;\x20&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>sections</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>6</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;version 1 header corrupted, not enough sections (got: %d, want: %d)&#34;</span>, len(<span style=color:#a6e22e>sections</span>), <span style=color:#ae81ff>6</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ProxyInfo</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Version</span>:  <span style=color:#e6db74>&#34;1&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>AddrType</span>: string(<span style=color:#a6e22e>sections</span>[<span style=color:#ae81ff>1</span>]),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>SrcAddr</span>:  string(<span style=color:#a6e22e>sections</span>[<span style=color:#ae81ff>2</span>]),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>DstAddr</span>:  string(<span style=color:#a6e22e>sections</span>[<span style=color:#ae81ff>3</span>]),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>SrcPort</span>:  string(<span style=color:#a6e22e>sections</span>[<span style=color:#ae81ff>4</span>]),
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>DstPort</span>:  string(<span style=color:#a6e22e>sections</span>[<span style=color:#ae81ff>5</span>]),
</span></span><span style=display:flex><span>	}, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=parsing-version-2>Parsing Version 2</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>version2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bufio&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;bytes&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;encoding/binary&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;errors&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;io&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;net&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;strconv&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// protocolV2HeaderLen represents the number of bytes needed</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// to start parsing the protocol v2 header.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>protocolV2HeaderLen</span> = <span style=color:#ae81ff>16</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// protocolV2SignatureBytes represents the 12 constant bytes of the v2 signature.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>protocolV2SignatureBytes</span> = []byte(<span style=color:#e6db74>&#34;\x0D\x0A\x0D\x0A\x00\x0D\x0A\x51\x55\x49\x54\x0A&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// ProxyInfo represents the PROXY protocol information.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ProxyInfo</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Version</span>           <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Command</span>           <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>AddrFamily</span>        <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>TransportProtocol</span> <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SrcAddr</span>           <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>SrcPort</span>           <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DstAddr</span>           <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>DstPort</span>           <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// MaybeParseVersion2 returns information about the proxy header if contained into</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// the buffered reader of an incoming request.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// No bytes are read from the buffered reader if there is no PROXY protocol header</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// prepended to the request.</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// If a PROXY protocol header is found, only the bytes of the PROXY protocol</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// are consumed from the reader to allow the rest of the bytes to be used for</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// a layer 7 protocol for example HTTP.</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>MaybeParseVersion2</span>(<span style=color:#a6e22e>bufReader</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bufio</span>.<span style=color:#a6e22e>Reader</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>ProxyInfo</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Peek at enough bytes to be able to know if the protocol is a version 2</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// and to get the length of the PROXY protocol header.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sigBytes</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bufReader</span>.<span style=color:#a6e22e>Peek</span>(<span style=color:#a6e22e>protocolV2HeaderLen</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;peek error: %w&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Check if the peeked bytes start with a version 2 signature.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>isV2</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>sigBytes</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>protocolV2HeaderLen</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>sigBytes</span>[:len(<span style=color:#a6e22e>protocolV2SignatureBytes</span>)], <span style=color:#a6e22e>protocolV2SignatureBytes</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>isV2</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// sigBytes[12] contains the version</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Check if the version == 2</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sigBytes</span>[<span style=color:#ae81ff>12</span>]<span style=color:#f92672>&gt;&gt;</span><span style=color:#ae81ff>4</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0x2</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unknown version of protocol&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// sigBytes[14:16] contains the length of the addresses</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Integer are sent over the wire using network byte order.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// To use them as integer we need to translate them into</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// a go primitive.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lenInt</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>Uint16</span>(<span style=color:#a6e22e>sigBytes</span>[<span style=color:#ae81ff>14</span>:<span style=color:#ae81ff>16</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// The total header length is the length of the address plus the</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// constant length of 16 (signature + version + bytes for length)</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>hdrLenInt</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>16</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>lenInt</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Consume bytes from the request since we now know the request contains a</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// version 2 header and we have the length of the header.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>line</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>hdrLenInt</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>io</span>.<span style=color:#a6e22e>ReadFull</span>(<span style=color:#a6e22e>bufReader</span>, <span style=color:#a6e22e>line</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ProxyInfo</span>{
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>Version</span>: <span style=color:#e6db74>&#34;2&#34;</span>,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// line[12] contains the command</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Parse lower bits of 13th byte</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// AND 4 higher bits with zero (making them zero)</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>12</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x01</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>c</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x0</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Command</span> = <span style=color:#e6db74>&#34;LOCAL&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x1</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>Command</span> = <span style=color:#e6db74>&#34;PROXY&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unknown version 2 command&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// line[13] contains the address family and the transport protocol.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Parse higher bits of 14th byte for the address family.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// From 11110000 to 00001111 where the 4 first bits</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// are shifted to the right.</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>af</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>13</span>] <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>af</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x0</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>AddrFamily</span> = <span style=color:#e6db74>&#34;AF_UNSPEC&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x1</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>AddrFamily</span> = <span style=color:#e6db74>&#34;AF_INET&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x2</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>AddrFamily</span> = <span style=color:#e6db74>&#34;AF_INET6&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x3</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>AddrFamily</span> = <span style=color:#e6db74>&#34;AF_UNIX&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unknown version 2 Address Family&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Parse lower bits of 14th byte for the transport protocol.</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// AND 4 higher bits with zero (making them zero)</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>13</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x01</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>tp</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x0</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>TransportProtocol</span> = <span style=color:#e6db74>&#34;UNSPEC&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x1</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>TransportProtocol</span> = <span style=color:#e6db74>&#34;STREAM&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x2</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>TransportProtocol</span> = <span style=color:#e6db74>&#34;DGRAM&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unknown version 2 Transport Protocol&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Infer the Address and Port types by using the combination of</span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Address Family and Transport Protocol.</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>13</span>] {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x00</span>:
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>SrcAddr</span> = <span style=color:#e6db74>&#34;UNSPEC&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>SrcPort</span> = <span style=color:#e6db74>&#34;UNSPEC&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>DstAddr</span> = <span style=color:#e6db74>&#34;UNSPEC&#34;</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>DstPort</span> = <span style=color:#e6db74>&#34;UNSPEC&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x11</span>: <span style=color:#75715e>// TCP + IPv4</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>SrcAddr</span> = <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>IP</span>(<span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>16</span>:<span style=color:#ae81ff>20</span>]).<span style=color:#a6e22e>String</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>DstAddr</span> = <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>IP</span>(<span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>20</span>:<span style=color:#ae81ff>24</span>]).<span style=color:#a6e22e>String</span>()
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Translate network byte order integer into a go primitive.</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>SrcPort</span> = <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatUint</span>(uint64(<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>Uint16</span>(<span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>24</span>:<span style=color:#ae81ff>26</span>])), <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>DstPort</span> = <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatUint</span>(uint64(<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>Uint16</span>(<span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>26</span>:<span style=color:#ae81ff>28</span>])), <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>case</span> <span style=color:#ae81ff>0x21</span>: <span style=color:#75715e>// TCP + IPv6</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>SrcAddr</span> = <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>IP</span>(<span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>16</span>:<span style=color:#ae81ff>32</span>]).<span style=color:#a6e22e>String</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>DstAddr</span> = <span style=color:#a6e22e>net</span>.<span style=color:#a6e22e>IP</span>(<span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>32</span>:<span style=color:#ae81ff>48</span>]).<span style=color:#a6e22e>String</span>()
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Translate network byte order integer into a go primitive.</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>SrcPort</span> = <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatUint</span>(uint64(<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>Uint16</span>(<span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>48</span>:<span style=color:#ae81ff>50</span>])), <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>DstPort</span> = <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatUint</span>(uint64(<span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>Uint16</span>(<span style=color:#a6e22e>line</span>[<span style=color:#ae81ff>50</span>:<span style=color:#ae81ff>52</span>])), <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>errors</span>.<span style=color:#a6e22e>New</span>(<span style=color:#e6db74>&#34;unknown version 2 Address Type and Transport Protocol combination&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=real-life-usage>Real-life Usage</h2><p>After looking at how PROXY protocol works and how it can be implemented. Let&rsquo;s look at some Cloud providers to see where the protocol is used. To do so, here is a list of Load Balancers for each providers with the mechanism used to preserve the Client Address.</p><h3 id=azure>Azure</h3><ul><li>Front Door Service is a layer 7 proxy that supports injecting the <a href=https://docs.microsoft.com/en-us/azure/frontdoor/front-door-http-headers-protocol target=_blank rel=noopener>X-Forwarded-For header</a></li><li>Application Gateway is a layer 7 proxy that supports injecting the <a href=https://docs.microsoft.com/en-us/azure/application-gateway/how-application-gateway-works#modifications-to-the-request target=_blank rel=noopener>X-Forwarded-For header</a></li><li>Azure Load Balancer is a Network Load Balancer that <a href=https://docs.microsoft.com/en-us/azure/load-balancer/concepts-limitations target=_blank rel=noopener>preserves the Client IP</a>
by only being a pass-through Load Balancer.</li></ul><h3 id=google-cloud-platform>Google Cloud Platform</h3><p>The six different Load Balancers are summarized by Google with one of the feature covered being <code>Preserve Client IP</code>:</p><figure><img src=/posts/2020-02-exploring-the-proxy-protocol/gcp-load-balancers.png alt="Google Cloud Platform Load Balancers Comparison"></figure><p>Google also has more detailed comparison going as far as explaining how preservation of client IP can be done with the various Load Balancers:</p><figure><img src=/posts/2020-02-exploring-the-proxy-protocol/gcp-client-ip-preservation.png alt="Google Cloud Platform Client IP Preservation"></figure><p>The <code>TCP Proxy Header</code> referred to in this table refers to the PROXY protocol. Therefore, TCP and SSL Proxies <a href=https://cloud.google.com/load-balancing/docs/tcp/setting-up-tcp#proxy-protocol target=_blank rel=noopener>support the PROXY protocol</a>
.</p><h3 id=amazon-web-services>Amazon Web Services</h3><ul><li>Classic Load Balancer (previously named ELB/Elastic Load Balancer) <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/enable-proxy-protocol.html target=_blank rel=noopener>supports the PROXY protocol version 1 for TCP listeners</a>
. It also supports <code>X-Forwarded-For</code> for <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/classic/x-forwarded-headers.html target=_blank rel=noopener>HTTP listeners</a>
.</li><li>Network Load Balancer preserves the source address and port without the <code>X-Forwarded-For</code> header or the PROXY protocol when targets are identified by instance ID. When targets are identified by IP address, the source address is not preserved. To work around this limitation, the Network Load Balancer supports the <a href=https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-target-groups.html target=_blank rel=noopener>PROXY protocol version 2</a>
.</li><li>Application Load Balancers (ALB) automatically forward the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For target=_blank rel=noopener>X-Forwarded-For</a>
header to their targets.</li></ul><h3 id=cloudflare>Cloudflare</h3><p>Cloudflare supports injecting both a <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For target=_blank rel=noopener>X-Forwarded-For</a>
header and also <a href=https://developers.cloudflare.com/spectrum/getting-started/proxy-protocol/ target=_blank rel=noopener>the PROXY protocol header</a>
.</p><h3 id=digitalocean>DigitalOcean</h3><p>The <a href=https://www.digitalocean.com/docs/networking/load-balancers/ target=_blank rel=noopener>DigitalOcean Load Balancer</a>
has support for the PROXY protocol version. It also supports the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For target=_blank rel=noopener>X-Forwarded-For</a>
header when proxying HTTP.</p><h3 id=linode>Linode</h3><p>The Linode NodeBalancer has support for the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For target=_blank rel=noopener>X-Forwarded-For</a>
header. PROXY protocol support is <a href=https://www.linode.com/2019/12/30/2019-a-year-in-review/ target=_blank rel=noopener>planned for 2020</a>
.</p><h3 id=rackspace>Rackspace</h3><p>The Rackspace Cloud Load Balancer has support for the <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For target=_blank rel=noopener>X-Forwarded-For</a>
header. It does not support PROXY protocol.</p><h2 id=alternatives>Alternatives</h2><p>The PROXY protocol exists to ensure that the client IP / source address of the original request is preserved across hops to upstream servers. We&rsquo;ve covered a lot on the PROXY protocol. But as seen by the approaches taken by Cloud Providers, there are other approaches than using some sort of layer 4 or 7 proxy to perform load balancing. These approaches are very interesting and promising. They make the PROXY protocol less and less needed.</p><p>The Kubernetes proxy, Kube-Proxy, has <a href=https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies target=_blank rel=noopener>different interesting approaches</a>
to proxying while preserving the Client IP. It can work in 3 modes: userspace, iptables, and <a href=https://en.wikipedia.org/wiki/IP_Virtual_Server target=_blank rel=noopener>IPVS</a>
. The userspace mode requires the proxy to do the TCP handshake and therefore does not preserve the original Client IP. The iptable and IPVS modes both allow the kernel to perform the routing without reading the traffic and therefore both preserve the client IP without needing the PROXY protocol. The new IPVS approach also allow different load-balancing algorithm like lest conns, locality, weighted, &mldr;</p><p>There is also the big domain of <a href=https://en.wikipedia.org/wiki/Software-defined_networking target=_blank rel=noopener>Software Defined Networking</a>
that allows a service provider to configure switches to perform load-balancing by the network instead of by an application or proxy. This seems to be the approach taken by various Cloud Providers. Leveraging the network to perform the load balancing gets rid of single point of failures and increases performance. There can even be some advanced heuristics to improve load balancing algorithms like TCP performance, QoS, locality, least conns, &mldr;</p><p>There are also different tunneling/encapsulation protocol allowing incoming packets to be wrapped within another protocol and be delivered transparently as-is to the target application. One such protocol is the <a href=https://en.wikipedia.org/wiki/IP_in_IP target=_blank rel=noopener>IP-in-IP</a>
tunneling protocol. IP-in-IP is supported natively by the Linux kernel and allows wrapping IP packets within another IP packet transparently.</p><p>Networking is a big world composed of so many different technologies. This list is just a tiny window in this wide world.</p><h2 id=conclusion>Conclusion</h2><p>After taking a look at the PROXY protocol spec and after looking at how to implement it, I hope that I have been able to demystify it a little bit for you. Like almost everything we get to learn, it opens new doors and so many new questions. One thing is sure. Even though most of us will never have to create a PROXY protocol reader or writer, understanding the PROXY protocol makes us better at understanding trade-offs when choosing a Proxy or Load-Balancer for our applications.</p><p>The code snippets of this post are coming from a small project called <a href=https://github.com/seriousben/proxy-debugger target=_blank rel=noopener>Proxy Debugger</a>
. That project was created while writing this post. It is a server that outputs information about incoming requests like for example the Client IP, the X-Forwarded-For header, and the various PROXY Protocol header fields.</p></div></div><div></div></div><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js integrity="sha512-EBLzUL8XLl+va/zAsmXwS7Z2B1F9HUHkZwyS/VKwh3S7T/U0nF4BaU29EP/ZSf6zgiIxYAnKLu6bJ8dqpmX5uw==" crossorigin=anonymous></script><script>window.addEventListener("load",function(){hljs.highlightAll()},!0)</script></body></html>