<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Patch Coverage - Benjamin Boudreau</title><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=referrer content="no-referrer"><meta name=description content><meta property="og:site_name" content="Benjamin Boudreau"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:url" content="https://seriousben.com/posts/2022-02-patch-coverage/"><meta property="og:title" content="Patch Coverage"><meta property="og:image" content="https://seriousben.com/"><meta property="og:description" content><meta property="twitter:site" content="@seriousben"><meta property="twitter:title" content="Patch Coverage"><meta property="twitter:image" content="https://seriousben.com/"><meta property="twitter:card" content="summary"><meta property="twitter:description" content><link rel=canonical href=https://seriousben.com/posts/2022-02-patch-coverage/><link rel=stylesheet href=https://seriousben.com/style.d44234584139078e87c89dd53eda56c2d1f231c980bdd5bfb6b2e6b4f6bc6f43.css integrity="sha256-1EI0WEE5B46HyJ3VPtpWwtHyMcmAvdW/trLmtPa8b0M=" crossorigin=anonymous><link rel=stylesheet href=https://seriousben.com/css/highlight.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#000><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title="Benjamin Boudreau"></head><body><div class=container><header><div class=title-wrapper><a href=https://seriousben.com/>Serious Ben</a></div><div class=menu><ol><li><a class="text-uppercase nav-link" href=/posts/>Posts</a></li><li><a class="text-uppercase nav-link" href=/links/>Curated Links</a></li></ol></div></header><div class=content><h1>Patch Coverage</h1><div class=meta><span class=date title="Sat Feb 12 2022 00:00:00 UTC">February 12, 2022</span>
&bull;
<span class="reading-time middot">11 minutes</span></div><div class=article-content><p>Code Coverage as a way to track code quality has existed for as long as code
exists. For that same amount of time, different schools of thought have debated
on how best to leverage coverage to help drive quality. For example, the
concept of <a href=https://en.wikipedia.org/wiki/Modified_condition/decision_coverage>Modified condition/decision
coverage</a>
which defines a criterion used in avionics, in automotive, and in lots of
safety-critical systems has been referred to in standards <a href=https://en.wikipedia.org/wiki/DO-178B>created in
1992</a>.</p><p>But this post is not exploring the philosophical aspects of code coverage. It
is about one metric we get with coverage: patch code coverage.
We&rsquo;ll explore what it is and how it can be used to write better code, how it
can be determined, and we&rsquo;ll have an extensive example of how it can be
implemented for go programs and integrated with Github Actions.</p><p>When changing code, you typically have two coverage data points: the project
coverage before and the one after a change. There is another datapoint that is
often forgotten, the coverage of the changed code. The patch coverage.</p><p>Patch coverage makes it easy to understand whether you&rsquo;ve merely improved
coverage of existing code or have added coverage for the new code. Afterall, It
is possible to increase coverage of a project without adding any tests to new
or changed files in one patch.</p><p>Let&rsquo;s dig deeper in figuring out how to answer: &ldquo;How much of the new
code I am introducing is covered by tests?&rdquo;.</p><h2 id=everyday-usage>Everyday Usage</h2><p>Patch Coverage is already part of our day to day life. Your code editor is most
likely allowing you to look at code coverage as you work on new code and tests.</p><p>For example:</p><ul><li>Goland <a href=https://www.jetbrains.com/help/go/code-coverage.html>https://www.jetbrains.com/help/go/code-coverage.html</a></li><li>Vim-go <a href=https://github.com/fatih/vim-go/wiki/Tutorial#cover-it>https://github.com/fatih/vim-go/wiki/Tutorial#cover-it</a></li><li>VS Code <a href=https://github.com/golang/vscode-go/blob/master/docs/features.md#code-coverage>https://github.com/golang/vscode-go/blob/master/docs/features.md#code-coverage</a></li></ul><figure class=large-figure><img src=/posts/2022-02-patch-coverage/vscode-coverage.png alt="VS Code Golang Coverage"><figcaption><p>Figure 1: VS Code Patch Coverage</p></figcaption></figure><p>These tools are amazing at providing you quick coverage data feedback as you write tests to
let you know what needs more coverage.</p><p>If you are not that capability in all features you are working on, I highly
suggest turning it on to accelerate writing meaningful tests.</p><p>But what about getting the actual coverage number for the new and changed
lines of your patch? That number is super useful to convey changed file
coverage on pull-request or, depending on your testing philosophy, as a policy
enforcement check (for example: All code changes require at least 90%
coverage). That number is also very actionable for engineers working in that
area of the code. It is numbers about the code they changed or added after all.
So making those numbers visible automatically provides the team with a feedback loop
making them consider the test coverage of their new code.</p><h2 id=implementation>Implementation</h2><p>The implementation of patch coverage is relatively simple. It requires mapping
coverage data to the patch diff in order to only keep any coverage data for lines
that have changed.</p><figure class=large-figure><img src=/posts/2022-02-patch-coverage/patch-coverage-formula.png alt="Patch Coverage Formula: Coverage Data + Patch = Patch Coverage"><figcaption><p>Figure 1: Patch Coverage Formula</p></figcaption></figure><p>Since coverage data is different for each programming language
, we will be focusing on the <a href=https://golang.org/>Go Programming Language</a> to look at
implementing patch coverage. We&rsquo;ll be going through the details behind
<a href=https://github.com/seriousben/go-patch-cover>go-patch-cover</a>. I created
<a href=https://github.com/seriousben/go-patch-cover>go-patch-cover</a> to provide code authors and reviewers
the tool necessary to understand the coverage of changed code without the use
of a third party coverage tool.</p><p>To implement go patch coverage we need two input files:</p><ol><li>The coverage data of the whole code base.</li><li>The patch data itself to identify what lines were added or changed.</li></ol><h3 id=coverage-data-go-coverage-profile>Coverage Data: Go Coverage Profile</h3><p>Let&rsquo;s understand the go coverage data format. Commonly named coverage profile.</p><p>The first line of a coverage profile contains the mode:</p><pre><code>mode: &lt;type&gt;
</code></pre><p>Where type can be &ldquo;set&rdquo;, &ldquo;count&rdquo;, or &ldquo;atomic&rdquo;.</p><p>The rest of the file looks like this:</p><pre><code>encoding/base64/base64.go:34.44,37.40 3 1
</code></pre><p>Which follows a specific format:</p><pre><code>name.go:line.column,line.column numberOfStatements count
</code></pre><p>Full example:</p><pre><code>mode: set
github.com/seriousben/go-patch-cover/cover.go:11.72,13.16 2 1
github.com/seriousben/go-patch-cover/cover.go:19.2,20.16 2 1
github.com/seriousben/go-patch-cover/cover.go:24.2,25.16 2 1
github.com/seriousben/go-patch-cover/cover.go:29.2,29.41 1 1
github.com/seriousben/go-patch-cover/cover.go:13.16,15.3 1 0
github.com/seriousben/go-patch-cover/cover.go:20.16,22.3 1 0
github.com/seriousben/go-patch-cover/cover.go:25.16,27.3 1 0
github.com/seriousben/go-patch-cover/cover.go:41.103,44.34 2 1
github.com/seriousben/go-patch-cover/cover.go:77.2,77.34 1 1
github.com/seriousben/go-patch-cover/cover.go:86.2,86.23 1 1
github.com/seriousben/go-patch-cover/cover.go:89.2,89.28 1 1
github.com/seriousben/go-patch-cover/cover.go:93.2,93.18 1 1
github.com/seriousben/go-patch-cover/cover.go:44.34,45.31 1 1
github.com/seriousben/go-patch-cover/cover.go:45.31,47.49 1 1
github.com/seriousben/go-patch-cover/cover.go:52.3,53.31 1 1
github.com/seriousben/go-patch-cover/cover.go:47.49,49.13 1 1
github.com/seriousben/go-patch-cover/cover.go:53.31,56.39 2 1
github.com/seriousben/go-patch-cover/cover.go:56.39,57.35 1 1
github.com/seriousben/go-patch-cover/cover.go:57.35,58.35 1 1
github.com/seriousben/go-patch-cover/cover.go:61.7,65.57 2 1
github.com/seriousben/go-patch-cover/cover.go:58.35,59.16 1 0
github.com/seriousben/go-patch-cover/cover.go:65.57,68.26 2 1
github.com/seriousben/go-patch-cover/cover.go:77.34,78.30 1 1
github.com/seriousben/go-patch-cover/cover.go:78.30,81.4 2 1
github.com/seriousben/go-patch-cover/cover.go:86.23,88.3 1 1
github.com/seriousben/go-patch-cover/cover.go:89.28,91.3 1 1
</code></pre><h4 id=interpretation>Interpretation</h4><p>Getting coverage information from a profile is straightforward.</p><p>First, we need to understand the difference in modes:</p><ul><li>Set: set to 1 when the the statements are covered</li><li>Count: count the number of times the statements ran</li><li>Atomic: Like count but accurately when dealing with parallelism / goroutine</li></ul><p>Second, we maintain two counters: a total number of statements, and number of covered
statements. For each profile block, add the number of the statement blocks to
the number of total statements. If the block has a count greater than zero
(zero being not covered and greater means covered) add the number of the
statement blocks to the number of covered statements.</p><p>And lastly, we compute the coverage by taking the number of covered statements divided by the
total number of statements.</p><p>This could be summarized with this pseudocode:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>total_num_statements</span> = <span style=color:#ae81ff>0</span>
<span style=color:#a6e22e>num_covered_statements</span> = <span style=color:#ae81ff>0</span>

<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>each</span> <span style=color:#a6e22e>profiles</span> <span style=color:#a6e22e>as</span> <span style=color:#a6e22e>profile</span>:
    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>each</span> <span style=color:#a6e22e>profile</span>.<span style=color:#a6e22e>blocks</span> <span style=color:#a6e22e>as</span> <span style=color:#a6e22e>block</span>:
        <span style=color:#a6e22e>total_num_statements</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>block</span>.<span style=color:#a6e22e>num_statements</span>
        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>block</span>.<span style=color:#a6e22e>count</span> &gt; <span style=color:#ae81ff>0</span>:
            <span style=color:#a6e22e>num_covered_statements</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>block</span>.<span style=color:#a6e22e>num_statements</span>

<span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>elegant</span> <span style=color:#a6e22e>tip</span> <span style=color:#a6e22e>from</span> <span style=color:#a6e22e>the</span> <span style=color:#66d9ef>go</span> <span style=color:#a6e22e>tools</span> <span style=color:#a6e22e>code</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>prevent</span> <span style=color:#a6e22e>division</span> <span style=color:#a6e22e>by</span> <span style=color:#a6e22e>zero</span>.
<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>total_num_statements</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
    <span style=color:#a6e22e>total_num_statements</span> = <span style=color:#ae81ff>1</span>

<span style=color:#a6e22e>coverage</span> = <span style=color:#a6e22e>num_covered_statements</span> <span style=color:#f92672>/</span> <span style=color:#a6e22e>total_num_statements</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>100</span>
</code></pre></div><h3 id=the-patch-unified-diff>The Patch: Unified Diff</h3><p>The patch itself will be a <a href=https://www.gnu.org/software/diffutils/manual/diffutils.html#Detailed-Unified>unified diff</a>
file.</p><p>Each file changed in the patch has its own section in the
unified diff file which is composed of:</p><ul><li>Header for the file<ul><li><pre><code>diff --git a/cmd/main.go b/cmd/main.go
new file mode 100644
index 0000000..e6deb13
--- /dev/null
+++ b/cmd/main.go
</code></pre></li></ul></li><li>Hunks for each change section</li></ul><p>Each Hunk is composed of:</p><ul><li>Header for the hunk, line start and end<ul><li><pre><code>@@ -1 +1 @@
</code></pre></li></ul></li><li>Context lines: Code that has not changed to faciliate reviewing. Number of context is typically configurable.</li><li>Changed lines prefixed with + or - for addition or deletion<ul><li><pre><code>@@ -1 +1 @@
-package main
+package patchcover
@@ -4,2 +3,0 @@ import (
-	&quot;fmt&quot;
-	&quot;log&quot;
</code></pre></li></ul></li></ul><p><strong>Complete Example (without context lines):</strong></p><p>Generated using <code>git diff -U0</code>.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff>diff --git a/cmd/main.go b/cmd/main.go
new file mode 100644
index 0000000..e6deb13
<span style=color:#f92672>--- /dev/null
</span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/cmd/main.go
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -0,0 +1,18 @@
</span><span style=color:#75715e></span><span style=color:#a6e22e>+package main
</span><span style=color:#a6e22e>+
</span><span style=color:#a6e22e>+import (
</span><span style=color:#a6e22e>+	&#34;fmt&#34;
</span><span style=color:#a6e22e>+	&#34;log&#34;
</span><span style=color:#a6e22e>+
</span><span style=color:#a6e22e>+	patchcover &#34;github.com/seriousben/go-patch-cover&#34;
</span><span style=color:#a6e22e>+)
</span><span style=color:#a6e22e>+
</span><span style=color:#a6e22e>+func main() {
</span><span style=color:#a6e22e>+	coverage, err := patchcover.ProcessFiles(&#34;testdata/scenarios/new_file/diff.diff&#34;, &#34;testdata/scenarios/new_file/coverage.out&#34;)
</span><span style=color:#a6e22e>+	if err != nil {
</span><span style=color:#a6e22e>+		log.Fatal(err)
</span><span style=color:#a6e22e>+	}
</span><span style=color:#a6e22e>+
</span><span style=color:#a6e22e>+	fmt.Printf(&#34;coverage: %.1f%% of statements\n&#34;, coverage.Coverage)
</span><span style=color:#a6e22e>+	fmt.Printf(&#34;patch coverage: %.1f%% of changed statements\n&#34;, coverage.PatchCoverage)
</span><span style=color:#a6e22e>+}
</span><span style=color:#a6e22e></span>diff --git a/main.go b/cover.go
similarity index 55%
rename from main.go
rename to cover.go
index 9a53c79..c07aadb 100644
<span style=color:#f92672>--- a/main.go
</span><span style=color:#f92672></span><span style=color:#a6e22e>+++ b/cover.go
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -1 +1 @@
</span><span style=color:#75715e></span><span style=color:#f92672>-package main
</span><span style=color:#f92672></span><span style=color:#a6e22e>+package patchcover
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -4,2 +3,0 @@ import (
</span><span style=color:#75715e></span><span style=color:#f92672>-	&#34;fmt&#34;
</span><span style=color:#f92672>-	&#34;log&#34;
</span><span style=color:#f92672></span><span style=color:#75715e>@@ -13,2 +11,2 @@ import (
</span><span style=color:#75715e></span><span style=color:#f92672>-func main() {
</span><span style=color:#f92672>-	patch, err := os.Open(&#34;testdata/scenarios/new_file/diff.diff&#34;)
</span><span style=color:#f92672></span><span style=color:#a6e22e>+func ProcessFiles(diffFile, coverageFile string) (CoverageData, error) {
</span><span style=color:#a6e22e>+	patch, err := os.Open(diffFile)
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -16 +14 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-		log.Fatal(err)
</span><span style=color:#f92672></span><span style=color:#a6e22e>+		return CoverageData{}, err
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -23 +21 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-		log.Fatal(err)
</span><span style=color:#f92672></span><span style=color:#a6e22e>+		return CoverageData{}, err
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -26 +24 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-	profiles, err := cover.ParseProfiles(&#34;testdata/scenarios/new_file/coverage.out&#34;)
</span><span style=color:#f92672></span><span style=color:#a6e22e>+	profiles, err := cover.ParseProfiles(coverageFile)
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -28 +26 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-		log.Fatal(err)
</span><span style=color:#f92672></span><span style=color:#a6e22e>+		return CoverageData{}, err
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -31,6 +29,11 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-	var (
</span><span style=color:#f92672>-		numStmt         int
</span><span style=color:#f92672>-		coverCount      int
</span><span style=color:#f92672>-		patchNumStmt    int
</span><span style=color:#f92672>-		patchCoverCount int
</span><span style=color:#f92672>-	)
</span><span style=color:#f92672></span><span style=color:#a6e22e>+	return computeCoverage(files, profiles)
</span><span style=color:#a6e22e>+}
</span><span style=color:#a6e22e>+
</span><span style=color:#a6e22e>+type CoverageData struct {
</span><span style=color:#a6e22e>+	NumStmt         int
</span><span style=color:#a6e22e>+	CoverCount      int
</span><span style=color:#a6e22e>+	Coverage        float64
</span><span style=color:#a6e22e>+	PatchNumStmt    int
</span><span style=color:#a6e22e>+	PatchCoverCount int
</span><span style=color:#a6e22e>+	PatchCoverage   float64
</span><span style=color:#a6e22e>+}
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -37,0 +41,2 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#a6e22e>+func computeCoverage(diffFiles []*gitdiff.File, coverProfiles []*cover.Profile) (CoverageData, error) {
</span><span style=color:#a6e22e>+	var data CoverageData
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -39,2 +44,2 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-	for _, p := range profiles {
</span><span style=color:#f92672>-		for _, f := range files {
</span><span style=color:#f92672></span><span style=color:#a6e22e>+	for _, p := range coverProfiles {
</span><span style=color:#a6e22e>+		for _, f := range diffFiles {
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -50 +55 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-				patchNumStmt += b.NumStmt
</span><span style=color:#f92672></span><span style=color:#a6e22e>+				data.PatchNumStmt += b.NumStmt
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -62 +67 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-							patchCoverCount += b.NumStmt * b.Count
</span><span style=color:#f92672></span><span style=color:#a6e22e>+							data.PatchCoverCount += b.NumStmt * b.Count
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -72 +77 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-	for _, p := range profiles {
</span><span style=color:#f92672></span><span style=color:#a6e22e>+	for _, p := range coverProfiles {
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -74,2 +79,2 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-			numStmt += b.NumStmt
</span><span style=color:#f92672>-			coverCount += b.NumStmt * b.Count
</span><span style=color:#f92672></span><span style=color:#a6e22e>+			data.NumStmt += b.NumStmt
</span><span style=color:#a6e22e>+			data.CoverCount += b.NumStmt * b.Count
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -81,4 +86,2 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-	if numStmt != 0 {
</span><span style=color:#f92672>-		fmt.Printf(&#34;coverage: %.1f%% of statements\n&#34;, float64(coverCount)/float64(numStmt)*100)
</span><span style=color:#f92672>-	} else {
</span><span style=color:#f92672>-		fmt.Printf(&#34;coverage: %d%% of statements\n&#34;, 0)
</span><span style=color:#f92672></span><span style=color:#a6e22e>+	if data.NumStmt != 0 {
</span><span style=color:#a6e22e>+		data.Coverage = float64(data.CoverCount) / float64(data.NumStmt) * 100
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -86,4 +89,2 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#f92672>-	if patchNumStmt != 0 {
</span><span style=color:#f92672>-		fmt.Printf(&#34;patch coverage: %.1f%% of changed statements\n&#34;, float64(patchCoverCount)/float64(patchNumStmt)*100)
</span><span style=color:#f92672>-	} else {
</span><span style=color:#f92672>-		fmt.Printf(&#34;patch coverage: %d%% of changed statements\n&#34;, 0)
</span><span style=color:#f92672></span><span style=color:#a6e22e>+	if data.PatchNumStmt != 0 {
</span><span style=color:#a6e22e>+		data.PatchCoverage = float64(data.PatchCoverCount) / float64(data.PatchNumStmt) * 100
</span><span style=color:#a6e22e></span><span style=color:#75715e>@@ -90,0 +92,2 @@ func main() {
</span><span style=color:#75715e></span><span style=color:#a6e22e>+
</span><span style=color:#a6e22e>+	return data, nil
</span></code></pre></div><p>go-patch-cover uses <a href=https://github.com/bluekeyes/go-gitdiff>https://github.com/bluekeyes/go-gitdiff</a> to parse diff files.</p><h3 id=mapping-coverage-profile-to-unified-diff>Mapping Coverage Profile to Unified Diff</h3><p>From these two types of file, we can get the patch coverage number.</p><p>Patch coverage is simply finding the covered and total number of statements that
are contained within a changed section of a file.</p><p>This pseudocode explains some of the intricacies needed to do so:</p><pre><code># coverageOfBlock computes the num of covered and total statements of a coverage block
# if contained as an added line of the patched file.
func coverageOfBlock(coverage_block, file_patch) cover_count, total_count:
    for each hunks in file_patch.hunks:
        for each hunk_num, hunk_line in hunks:
            # For patch coverage, we only care about additions.
            if hunk_line !startsWith &quot;+&quot;:
               continue

            # Each line within hunk increments the line number, this includes context lines.
            line_num = hunk.new_position + hunk_num

            # Check if patch line within the coverage block stand and end.
            if coverage_block.start_line &lt;= line_num &amp;&amp; line_num &lt;= coverageBlock.end_line:
                total_count = coverage_block.num_statements
                cover_count = 0
                if coverage_block.count &gt; 0:
                    cover_count = coverage_block.num_statements

                return cover_count, total_count
   return 0, 0

total_num_statements = 0
num_covered_statements = 0
for each profile in coverage_profiles:
    for each file_patch in patch:
        if file_patch.name != profile.file_name:
            continue
        for each block in profile.blocks:
           c, t = coverageOfBlock(block, file_patch.hunks)
           total_num_statements += t
           num_covered_statements += c

# elegant tip from the go tools code to prevent division by zero.
if total_num_statements == 0:
    total_num_statements = 1

patch_coverage = num_covered_statements / total_num_statements * 100
</code></pre><h2 id=go-patch-cover>go-patch-cover</h2><p><a href=https://github.com/seriousben/go-patch-cover>go-patch-cover</a> is a tool I wrote to provide patch coverage for go. It also integrates with GitHub Actions via <a href=https://github.com/seriousben/go-patch-cover-action>go-patch-cover-action</a>.</p><pre><code>&gt; go-patch-cover coverage.out patch.diff

new coverage: 91.7% of statements
patch coverage: 96% of changed statements (48/50)

</code></pre><p><a href=https://github.com/seriousben/go-patch-cover>go-patch-cover</a> usage:</p><pre><code>Usage: go-patch-cover [--version] [--help] [flags...] coverage_file diff_file [previous_coverage_file]

Arguments:

coverage_file
    go coverage file for the code after patch was applied.
    Can be generated with any cover mode.
    Example generation:
        go test -coverprofile=coverage.out -covermode=count ./...

diff_file
    unified diff file of the patch to compute coverage for.
    Example generation:
        git diff -U0 --no-color origin/${GITHUB_BASE_REF} &gt; patch.diff

previous_coverage_file [OPTIONAL]
    go coverage file for the code before the patch was applied.
    When not provided, previous coverage information will not be displayed.

Flags:

--version
    display go-patch-cover version.

--help
    display this help message.

-o string
    output format: json, template; default: template.

-tmpl string
    go template string to override default template.

Examples:

Display total and patch coverage percentages to stdout:
    go-patch-cover coverage.out patch.diff

Display previous, total and patch coverage percentages to stdout:
    go-patch-cover coverage.out patch.diff prevcoverage.out

Display previous, total and patch coverage percentages as JSON to stdout:
    go-patch-cover -o json coverage.out patch.diff prevcoverage.out

Display patch coverage percentage to stdout by providing a custom template:
    go-patch-cover -tmpl &quot;{{ .PatchCoverage }}&quot; coverage.out patch.diff

</code></pre><h3 id=using-go-patch-cover-with-github-actions>Using go-patch-cover with GitHub Actions</h3><p><a href=https://github.com/seriousben/go-patch-cover-action>go-patch-cover-action</a> provies a GitHub Action
to keep track of the patch coverage or a pull request.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;CI&#34;</span>

<span style=color:#f92672>on</span>: [<span style=color:#e6db74>&#34;push&#34;</span>, <span style=color:#e6db74>&#34;pull_request&#34;</span>]

<span style=color:#f92672>permissions</span>:
  <span style=color:#f92672>contents</span>: <span style=color:#ae81ff>write</span>
  <span style=color:#f92672>pull-requests</span>: <span style=color:#ae81ff>write</span>

<span style=color:#f92672>jobs</span>:
  <span style=color:#f92672>ci</span>:
    <span style=color:#f92672>name</span>: <span style=color:#e6db74>&#34;Run CI&#34;</span>
    <span style=color:#f92672>runs-on</span>: <span style=color:#ae81ff>ubuntu-latest</span>
    <span style=color:#f92672>steps</span>:
    - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>actions/checkout@v2</span>
    - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>WillAbides/setup-go-faster@v1.7.0</span>
      <span style=color:#f92672>with</span>:
        <span style=color:#f92672>go-version</span>: <span style=color:#e6db74>&#34;*&#34;</span>
    - <span style=color:#f92672>run</span>: <span style=color:#e6db74>&#34;go test -coverprofile=coverage.out -covermode=count ./...&#34;</span>
    - <span style=color:#f92672>uses</span>: <span style=color:#ae81ff>seriousben/go-patch-cover-action@v1.0.0</span>
      <span style=color:#f92672>with</span>:
        <span style=color:#f92672>version</span>: <span style=color:#ae81ff>main</span>
</code></pre></div><figure class=large-figure><img src=/posts/2022-02-patch-coverage/go-patch-cover-action-example.png alt="Github Action Example"><figcaption><p>Figure 1: go-patch-cover-action example</p></figcaption></figure><h2 id=patch-coverage-in-third-party-tools>Patch Coverage in third party tools</h2><p>Patch Coverage is not new, some third party tools support it:</p><ul><li><a href=https://docs.codecov.com/docs/commit-status#patch-status>CodeCov&rsquo;s Patch coverage</a></li><li><a href=https://docs.codeclimate.com/docs/configuring-your-analysis#test-coverage>Code climate&rsquo;s Diff Coverage</a></li></ul><h2 id=closing-words>Closing Words</h2><p>Code Coverage is a tool in the software engineer&rsquo;s toolbox that should not be disregarded.
When used well, it can allow you to get quick feedback on your your code. Pariging it with
Patch Coverage allows teams to make local changes that slowly impact the quality of the
project as a whole.</p><p>Remember to approach testing with pragmatism. In a world where time to market and ability to pivot
are everything, 100% coverage is rarely a good idea. It is possible to leverage patch coverage to
ensure ever changing and high-risk code is well covered, while still focusing on flexibiity and
velocity.</p></div></div><div></div></div><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js integrity="sha512-Pbb8o120v5/hN/a6LjF4N4Lxou+xYZ0QcVF8J6TWhBbHmctQWd8O6xTDmHpE/91OjPzCk4JRoiJsexHYg4SotQ==" crossorigin=anonymous></script><script>window.addEventListener('load',function(){hljs.initHighlighting()},!0)</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-91134611-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>