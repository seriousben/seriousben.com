<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Worker process pattern, a story - Benjamin Boudreau</title><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=referrer content="no-referrer"><meta name=description content><meta property="og:site_name" content="Benjamin Boudreau"><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="og:url" content="https://seriousben.com/posts/worker-process-pattern-a-story/"><meta property="og:title" content="Worker process pattern, a story"><meta property="og:image" content="https://seriousben.com/"><meta property="og:description" content><meta property="twitter:site" content="@seriousben"><meta property="twitter:title" content="Worker process pattern, a story"><meta property="twitter:image" content="https://seriousben.com/"><meta property="twitter:card" content="summary"><meta property="twitter:description" content><link rel=canonical href=https://seriousben.com/posts/worker-process-pattern-a-story/><link rel=stylesheet href=https://seriousben.com/style.d44234584139078e87c89dd53eda56c2d1f231c980bdd5bfb6b2e6b4f6bc6f43.css integrity="sha256-1EI0WEE5B46HyJ3VPtpWwtHyMcmAvdW/trLmtPa8b0M=" crossorigin=anonymous><link rel=stylesheet href=https://seriousben.com/css/highlight.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color=#000><link rel="shortcut icon" href=/favicon.ico><link href rel=alternate type=application/rss+xml title="Benjamin Boudreau"></head><body><div class=container><header><div class=title-wrapper><a href=https://seriousben.com/>Serious Ben</a></div><div class=menu><ol><li><a class="text-uppercase nav-link" href=/posts/>Posts</a></li><li><a class="text-uppercase nav-link" href=/links/>Curated Links</a></li></ol></div></header><div class=content><h1>Worker process pattern, a story</h1><div class=meta><span class=date title="Sun Apr 14 2019 08:27:51 -0400">April 14, 2019</span></div><div class=article-content><p>This post is just a little funny story to explain why you might need a worker process in your architecture. It roughly follows the Pixar storytelling formula.</p><p>There are more technical details at the end.</p><h1 id=the-story>The story</h1><p>Once upon a time there was an API. It was a popular API. With popularity came responsibilities which meant that it had to do a lot of different things. For example, sending emails, looking at Reddit and other important API work.</p><p>Every day, it was serving so many requests and for each of those it had to do so much work. To complete these requests, it had to go through different types of tasks. But the more it did, the longer it started to take for requests to be fully complete.</p><p>One day, one of the many things the API worked on broke. It did not know what to do and just left most of its operations in an incomplete state. It may have sent some or all emails, it may have posted some or all cat pictures on Reddit, it may have saved that piece of data in the database or not.</p><p>Because of that, it&rsquo;s developers were not very happy. They were seeing how slow the API was at doing its job and how most of the time the jobs were half done. The API started to think about a way to become better and faster. The API realized that to do so it had to handle more requests and also do less work.</p><p>Because of that, the API decided to reach out for help in it&rsquo;s professional network. The API was so lucky. A good hard-working friend was looking for work. That friend was the perfect fit since he liked doing stuff asynchronously and working very hard.</p><p>A friend that would allow the API to take it easy at last.</p><p>Until finally, the API asks its friend for help. The API started handling requests and its friend worked through all the queued jobs one by one.</p><p>They gave scalability, observability, reliability and most importantly peace of mind to their dear developers.</p><p>Never again would the API make its developers sad.</p><h1 id=application-in-real-life>Application in real life</h1><p>The worker pattern or background job pattern or work queue pattern is not new. It is implemented in so many languages and platforms.</p><p>Heroku has a <a href=https://devcenter.heroku.com/articles/background-jobs-queueing>good description on it</a>.</p><p>Slack has a good <a href=https://slack.engineering/scaling-slacks-job-queue-687222e9d100>real world example overview of how they use that pattern</a></p><p>The first thing to ask yourself when implementing this pattern is what backing store to use for your work queue.</p><p>Normally, people have these choices:</p><ul><li><strong>No backing store</strong>, doing everything in-process / in-memory. Depending on your type of work this might be the cheapest approach to take. But be sure to know the limits of such an approach. By not using a backing store you risk losing all worked queued up when the process restarts. You also cannot scale differently the workers and the APIs servers. And you cannot have specialized workers for different types of jobs.</li><li><strong>Their database.</strong> For example leveraging their existing Mongo or PostgreSQL infrastructure to store the queue of work. This approach is the pragmatic one. It gives you reliability and scalability advantages over the in-memory options. But it can become too slow for high throughput operations.</li><li><strong>A dedicated data source</strong> to store the queue of work. This is definitely a popular choice. This allows you to scale to lots of workers and lots of jobs while giving you advanced capabilities like priorities and some quality of service like at-least-once or exactly-once processing of a message. In most cases it also makes it easy to have a polyglot architecture where multiple frameworks and languages might consume and do work from queue. Kafka, Rabbitmq, Redis are examples of backing stores that can be used for this.</li></ul><p>In go, you can leverage some existing libraries to tackle this problem:</p><ul><li><a href=https://github.com/gocraft/work>https://github.com/gocraft/work</a> leverages Redis.</li><li><a href=https://github.com/RichardKnop/machinery>https://github.com/RichardKnop/machinery</a> supports multiple backing stores like Redis, AWS Simple Queue Service (SQS) and AMQP.</li><li><a href=https://github.com/Shopify/sarama>https://github.com/Shopify/sarama</a> can be leveraged to use kafka as a work queue.</li><li><a href=https://github.com/bgentry/que-go>https://github.com/bgentry/que-go</a> leverages PostgreSQL as a backing store for your work queue.</li></ul><p>This list is not exhaustive. There are tons of other good libraries to implement this pattern. <a href=https://github.com/avelino/awesome-go>Awesome Go</a> can be a good start to find similar libraries.</p></div></div><div></div></div><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.3.1/highlight.min.js integrity="sha512-Pbb8o120v5/hN/a6LjF4N4Lxou+xYZ0QcVF8J6TWhBbHmctQWd8O6xTDmHpE/91OjPzCk4JRoiJsexHYg4SotQ==" crossorigin=anonymous></script><script>window.addEventListener('load',function(){hljs.initHighlighting()},!0)</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-91134611-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>